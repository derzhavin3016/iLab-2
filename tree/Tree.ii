#include "Tree.hpp"

template <typename T>
ad6::Tree<T>::Tree( void ) : root_(nullptr),
                             size(0)
{
}

template <typename T>
void ad6::Tree<T>::Insert( const T &key )
{
  root_ = Insert(root_, key);
  ++size;
}

template <typename T>
ad6::Tree<T> &ad6::Tree<T>::operator <<( const T &key )
{
  Insert(key);

  return *this;
}

template <typename T>
void ad6::Tree<T>::Erase( const T &key )
{
  root_ = Delete(root_, key);
}

template <typename T>
void ad6::Tree<T>::Clear( void )
{
  if (root_ != nullptr)
    root_->Clear();
  delete root_;
  root_ = nullptr;
  size = 0;
}

template <typename T>
ad6::Tree<T>::~Tree( void )
{
  Clear();
}

template <typename T>
ad6::Node<T> *ad6::Tree<T>::RotR( Node<T> *nd )
{
  Node<T> *lnd = nd->left_;
  nd->left_ = lnd->right_;
  lnd->right_ = nd;
  nd->UpdDepth();
  lnd->UpdDepth();

  return lnd;
}

template <typename T>
ad6::Node<T> *ad6::Tree<T>::RotL( Node<T> *nd )
{
  Node<T> *rnd = nd->right_;
  nd->right_ = rnd->left_;
  rnd->left_ = nd;
  nd->UpdDepth();
  rnd->UpdDepth();

  return rnd;
}

template <typename T>
ad6::Node<T> *ad6::Tree<T>::Balance( Node<T> *nd )
{
  nd->UpdDepth();
  int bfact = nd->GetBFact();

  if (bfact >= 2)
  {
    if (nd->right_->GetBFact() < 0)
      nd->right_ = RotR(nd->right_);
    return RotL(nd);
  }
  if (bfact <= -2)
  {
    if (nd->left_->GetBFact() > 0)
      nd->left_ = RotL(nd->left_);
    return RotR(nd);
  }
  return nd;
}

template <typename T>
ad6::Node<T> *ad6::Tree<T>::Insert( Node<T> *nd, const T &key )
{
  if (nd == nullptr)
    return new Node<T>{key};
  if (key < nd->key_)
    nd->left_ = Insert(nd->left_, key);
  else if (key > nd->key_)
    nd->right_ = Insert(nd->right_, key);
  else
    return nd;

  return Balance(nd);
}

template <typename T>
ad6::Node<T> *ad6::Tree<T>::FindMin( Node<T> *nd )
{
  if (nd == nullptr)
    return nd;
  return FindMin(nd->left_);
}

template <typename T>
ad6::Node<T> *ad6::Tree<T>::DelMin( Node<T> *nd )
{
  if (nd->left_ == nullptr)
    return nd->right_;
  nd->left_ = DelMin(nd->left_);
  return Balance(nd);
}

template <typename T>
ad6::Node<T> *ad6::Tree<T>::Delete( Node <T> *nd, const T &key )
{
  if (nd == nullptr)
    return nullptr;
  if (key < nd->key_)
    nd->left_ = Delete(nd->left_, key);
  else if (key > nd->key_)
    nd->right_ = Delete(nd->right_, key);
  else // key == nd->key_
  {
    Node<T> *left = nd->left_;
    Node<T> *right = nd->right_;
    delete nd;

    if (right == nullptr)
      return left;

    Node<T> *min = FindMin(right);
    min->right_ = DelMin(right);
    min->left_ = left;

    return Balance(min);
  }

  return Balance(nd);
}